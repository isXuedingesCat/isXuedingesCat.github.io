<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++11 计时工具</title>
    <link href="/2022/07/27/c++11%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/07/27/c++11%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>利用c++11标准中的 chrono 库函数实现一个工作类，用于不同单位下耗时的统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerClock</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimerClock</span>() : <span class="hljs-built_in">m_begin</span>(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>()) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; m_begin = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); &#125;<br>    <span class="hljs-comment">//默认输出毫秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//微秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedMicro</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125; <br>    <span class="hljs-comment">//纳秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedNano</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedSeconds</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//分</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedMinutes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//时</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedHours</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_begin;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++手动实现求解根号</title>
    <link href="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/"/>
    <url>/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><strong>使用c++语言，在不使用库函数的情况下，实现根号运算操作</strong></p><h2 id="方式一-梯度下降法"><a href="#方式一-梯度下降法" class="headerlink" title="方式一 梯度下降法"></a>方式一 梯度下降法</h2><ol><li>将求解根号的问题转化为求解函数值解的问题，$\sqrt{x}$ 转化为 $L(t) = (t^2-x)^2$ 当 $L(t) = 0$ 时，$t$ 就是 $\sqrt{x}$ 的结果</li><li>寻找$t$合适的解，使 $L(t) = (t^2-x)^2 = 0$</li><li>找的 $t$ 的解即为需要的结果</li></ol><p><em>此时问题转化为求解 $L(t)$ 的极小值，也就是导数为0的点$</em></p><p><img src="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7%E5%9B%BE%E4%B8%80.png" alt="图一"></p><p>如果橙黄色曲线为 $L(t)$ 函数曲线，当 $t$ 出于与红色位置时，我们需要重新调整 $t$ 的位置，使得 $L(t)$ 的值接近0，此时的问题是将 $t$ 向左调整还是向右调整。</p><p>假设我们在x轴上的调整量为 $\Delta t$($\Delta t$为无穷小量), 此时可以比较将t向左与向右调整 $\Delta t$ 后 ,函数 $L(t\pm \Delta t)$ 的值与 ${L(t)}$ 值的关系。</p><p>如果 $L(t-\Delta t) &lt; L(t)$ 则 $t1 = t - \Delta t$</p><p>如果 $L(t+\Delta t) &lt; L(t)$ 则$t1 = t + \Delta t$</p><p>等价于</p><p>若 $L(t+\Delta t) - L(t) &lt; 0$则<br>$t1 = t + \Delta t$</p><p>若 $L(t-\Delta t) - L(t) &lt; 0$则<br>$t1 = t - \Delta t$</p><p>上两式可以合并为 $t1 = t - \frac{L(t+\Delta t)-L(t)}{\left| L(t+\Delta t) - L(t) \right|}\Delta t$ 其中 $\frac{L(t+\Delta t)-L(t)}{\left| L(t+\Delta t) - L(t) \right|}$ 的作用为取符号。<br>又可做如下的转换 $t1 = t - \frac{\frac{L(t+\Delta t) - L(t)}{\Delta t}}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}\Delta t =t - \frac{L(t+\Delta t) - L(t)}{\Delta t}*\frac{\Delta t}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}$ 其中 $\frac{L(t+\Delta t) - L(t)}{\Delta t}$ 为函数L在t点的导数，$\frac{\Delta t}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}$由于导数为常数，该部分可以视作无穷小。</p><p>此时上式可以化简为 $t1 = t - \alpha*\frac{L(t+\Delta t) - L(t)}{\Delta t} (\alpha \longrightarrow 0^+)$</p><p>这里只有当 $\alpha \longrightarrow 0^+$ 时，该行为才能够成立， $\alpha$也被视为步长。</p><p>当$\alpha$取无穷小时，虽然一定保证下降，但效率太慢，当设置较大值时，可能会暂时越过合适位置，但依然能够通过迭代重新回到合适位置附近，我们将$\alpha$称为学习率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> SQRT<br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @name: 使用导数求解根号</span><br><span class="hljs-comment">   * @msg: </span><br><span class="hljs-comment">   * @param &#123;double&#125; x 输入待求解的数值</span><br><span class="hljs-comment">   * @param &#123;double&#125; alpha 每一步更新的学习率</span><br><span class="hljs-comment">   * @param &#123;double&#125; precision 精度</span><br><span class="hljs-comment">   * @return &#123;*&#125; 返回求解得到的结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt1</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> alpha,<span class="hljs-type">double</span> precision = <span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">double</span> t = x/<span class="hljs-number">2.</span>;<br>    <span class="hljs-type">double</span> L = (t*t - x)*(t*t -x);<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">0.</span>;<br>    <span class="hljs-keyword">while</span> (L &gt; precision)<br>    &#123;<br>      d = <span class="hljs-number">2</span>*(t*t -x)*<span class="hljs-number">2</span>*t;<br>      t = t - alpha*d;<br>      L = (t*t - x)*(t*t -x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  cout&lt;&lt;SQRT::<span class="hljs-built_in">sqrt1</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">1e-8</span>)&lt;&lt;endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>\*<br>输出：<span class="hljs-number">1.41418</span><br>*\<br></code></pre></td></tr></table></figure><p><strong>方式一总结</strong></p><ol><li>梯度下降法是通过局部决定如何调整的算法，如果函数有多个极值，则可能陷入局部极值，因此初始值的选择直接影响收敛结果。</li><li>大的步长一定程度上能跨过局部极值，但也可能由于震荡导致不收敛</li><li>存在有一类算法，可以在一定范围内搜索一个合适步长，使每一次迭代更加稳定</li></ol><h2 id="方式二-牛顿法一"><a href="#方式二-牛顿法一" class="headerlink" title="方式二 牛顿法一"></a>方式二 牛顿法一</h2><p>梯度下降法多用于求解函数极小值的情况，而牛顿法则多用在求解 <strong>函数零点</strong> 时方程的根。</p><p>重新构造函数，将 $\sqrt{x}$ 转化为 $L(t) = t^2 - x$ 当 $L(t) = 0$时，t 就是需要的结果。</p><p><img src="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7%E5%9B%BE%E4%BA%8C.png" alt="图二"></p><p>在 o2 点建立坐标系，此时对于 $f(x)$ 在 $x1$ 处切线可以表示为 $f_o2(x2) = k(x2-x1)+b = f^`(x1)(x2-x1) = -f(x1)$ 最后一个等式可以通过 $o2$ 坐标系看出,在 $o2$ 坐标戏中，切线在 $x = x2$ 时 $y$ 值与 $-f(x1)$ 值相等。</p><p>将上式进行变换得到 </p><p>$x2 -x1 = -\frac{f(x1)}{f^`(x1)}$ </p><p>$x2 = x1 - \frac{f(x1)}{f^`(x1)}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @name: 牛顿法1求解根号</span><br><span class="hljs-comment"> * @msg: </span><br><span class="hljs-comment"> * @param &#123;double&#125; x 要求解的根号数值</span><br><span class="hljs-comment"> * @param &#123;double&#125; precision 精度要求</span><br><span class="hljs-comment"> * @return &#123;*&#125; 返回结果值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt2</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> precision=<span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">double</span> x1 = x/<span class="hljs-number">2.</span>;<br>  <span class="hljs-type">double</span> L = (x1*x1 - x);<br>  <span class="hljs-type">double</span> d = <span class="hljs-number">0.</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">abs</span>(L)&gt;precision)  <span class="hljs-comment">// 注意 abs 函数，可以从零点两侧逼近</span><br>  &#123;<br>    d = <span class="hljs-number">2</span>*x1;<br>    x1 = x1 - L/d;<br>    L = (x1*x1 - x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x1;<br>&#125;<br><span class="hljs-comment">// 输出 ： 1.41421</span><br></code></pre></td></tr></table></figure><h2 id="方式三-牛顿法2"><a href="#方式三-牛顿法2" class="headerlink" title="方式三 牛顿法2"></a>方式三 牛顿法2</h2><p>将原本牛顿法1中对 $L(x)$ 函数的定义转变为 $L(x) = f^<code>(x)$ 即原来 $L(s)$ 表示的是原函数的图像，现在表示的是导函数的图像。根据牛顿法1的结论 $t2 = t1 - \frac&#123;L(t)&#125;&#123;L^</code>(t)}$ 可以得到 $t2 = t1 - \frac{f^`(t)}{f^``(t)}$</p><p>此时将函数L定义为 $L(t) = (t^2 -x)^2 = 0$</p><p>以上要求 $f(x)$ 至少是二阶可导的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt3</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> precision=<span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">double</span> t = x/<span class="hljs-number">2.</span>;<br>    <span class="hljs-type">double</span> L = (t*t-x)*(t*t-x);<br>    <span class="hljs-type">double</span> d1 =<span class="hljs-number">0.</span>,d2=<span class="hljs-number">0.</span>;<br>    <span class="hljs-keyword">while</span>(L&gt;precision)<br>    &#123;<br>      d1 = <span class="hljs-number">2</span>*(t*t-x)*<span class="hljs-number">2</span>*t;<br>      d2 = <span class="hljs-number">12</span>*t*t - <span class="hljs-number">4</span>*x*t;<br>      t = t - d1/d2;<br>      L = (t*t -x)*(t*t-x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br><span class="hljs-comment">// 输出 ：1.41423 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
