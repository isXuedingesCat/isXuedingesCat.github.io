<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>spdlog使用</title>
    <link href="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></p><p><a href="https://github.com/gabime/spdlog">github地址</a></p><p>几个比较重要的文件：</p><ol><li>spdlog/spdlog.h 为日志库接口，提供日志宏的属性控制函数。</li><li>spdlog/logger.h 为日志管理器，为前后端连接的枢纽。</li><li>spdlog/async.h 为异步模式接口。</li><li>spdlog/sinks/base_sink.h 为日志文件格式父类，后面所有的日志文件格式都是继承该类来实现不同功能。</li><li>spdlog/sinks/registry.h 用于登记所有的logger，及一些默认的属性，如日志格式、日志写入等级。</li></ol><p>spdlog 日志级别,在set_levels 时只有大于设定日志级别的日志才会显示或打印<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><br>&#123;<br>    trace = <span class="hljs-number">0</span>,<br>    debug = <span class="hljs-number">1</span>,<br>    info = <span class="hljs-number">2</span>,<br>    warn = <span class="hljs-number">3</span>,<br>    err = <span class="hljs-number">4</span>,<br>    critical = <span class="hljs-number">5</span>,<br>    off = <span class="hljs-number">6</span><br>&#125; level_enum;<br></code></pre></td></tr></table></figure></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 以下两种方式都可以向日志中写入内容</span><br>    spdlog::<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;hello, &#123;&#125;!&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>    logger-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;hello &#123;&#125;,&#123;&#125;&quot;</span>,<span class="hljs-string">&quot;param&quot;</span>,<span class="hljs-number">123.4</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">效果：</span><br><span class="hljs-comment">    在生成的可执行文件所在目录生成 logs 目录，并自动创建 log_日期.log 的文件，向文件中写入信息 如下</span><br><span class="hljs-comment">    [2022-08-25 00:07:03.217][Thread 25][info][,]:hello, world!</span><br><span class="hljs-comment">    [2022-08-25 00:07:03.217][Thread 25][info][,]:hello param,123.4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>spdlog秉承这只包含你所需要的文件的原则，代码中应只包含你真正需要使用到的文件。<br>例如，如果你需要滚动日志，你需要包含头文件 “spdlog/sinks/rotating_file_sink.h”<br>同样的可以通过包含文件 “spdlog/async.h” 来获得异步日志特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span> <span class="hljs-comment">// support for basic file logging</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/rotating_file_sink.h&quot;</span> <span class="hljs-comment">// support for rotating file logging</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> <br>    &#123;<br>        <span class="hljs-comment">// Create basic file logger (not rotated)</span><br>        <span class="hljs-keyword">auto</span> my_logger = spdlog::<span class="hljs-built_in">basic_logger_mt</span>(<span class="hljs-string">&quot;basic_logger&quot;</span>, <span class="hljs-string">&quot;mylogs/basic.txt&quot;</span>);<br>        <br>        <span class="hljs-comment">// create a file rotating logger with 5mb size max and 3 rotated files</span><br>        <span class="hljs-keyword">auto</span> file_logger = spdlog::<span class="hljs-built_in">rotating_logger_mt</span>(<span class="hljs-string">&quot;file_logger&quot;</span>, <span class="hljs-string">&quot;mylogs/myfilename.txt&quot;</span>, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br><br>        my_logger-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;test, &#123;&#125;&quot;</span>,<span class="hljs-string">&quot;basic.txt&quot;</span>);<br>        file_logger-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;test, &#123;&#125; debug\n&quot;</span>,<span class="hljs-string">&quot;rotating_logger&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">spdlog::basic_logger_mt 创建基础的日志文件，第一个参数为日志名称，第二个参数表示 log 文件保存位置</span><br><span class="hljs-comment">spdlog::rotating_logger_mt 创建滚动日志文件，</span><br><span class="hljs-comment">执行效果:</span><br><span class="hljs-comment">    在生成的可执行文件目录下，生成两个文件夹 logs 和 mylogs ，其中logs 下有 log_日期.log 的文件，无内容。</span><br><span class="hljs-comment">    mylogs 下有basic.txt 文件，内容为 [2022-08-25 00:16:56.098][Thread 25][info][,]:test, basic.txt</span><br><span class="hljs-comment">    mulogs 下有 myfilename.txt 文件， 内容为 [2022-08-25 00:20:39.966][Thread 25][info][,]:test, rotating_logger debug</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>使用模板函数的方式创建异步logger<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/async.h&quot;</span> <span class="hljs-comment">//support for async logging.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> <br>    &#123;<br>        <span class="hljs-keyword">auto</span> async_file = spdlog::<span class="hljs-built_in">basic_logger_mt</span>&lt;spdlog::async_factory&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; ++i)<br>        &#123;<br>            async_file-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Async message #&#123;&#125;&quot;</span>, i);<br>        &#125;<br>        <span class="hljs-comment">// Under VisualStudio, this must be called before main finishes to workaround a known VS issue</span><br>        spdlog::<span class="hljs-built_in">drop_all</span>(); <br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行效果:</span><br><span class="hljs-comment">    创建 logs 文件夹，其中包含有 log_日期.log文件，无内容，另包含有 async_log.txt 文件，内容为循环中写入的一百行信息，只列出一行 [2022-08-25 00:22:35.588][Thread 25][info][,]:Async message #1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><p>创建异步日志并更改线程池设置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/async.h&quot;</span> <span class="hljs-comment">//support for async logging</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/daily_file_sink.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>* [])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;                                        <br>        <span class="hljs-comment">// 创建一个 daily_sink 对象，从结构图中可以看出sink对象负责对日志文件的写入工作</span><br>        <span class="hljs-keyword">auto</span> daily_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_mt&gt;(<span class="hljs-string">&quot;logs/dailylog&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>);<br>        <span class="hljs-comment">// default thread pool settings can be modified *before* creating the async logger:</span><br>        <span class="hljs-comment">// 异步操作需要创建线程池</span><br>        spdlog::<span class="hljs-built_in">init_thread_pool</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// queue with 10K items and 1 backing thread.</span><br>        <span class="hljs-keyword">auto</span> async_file = spdlog::<span class="hljs-built_in">basic_logger_mt</span>&lt;spdlog::async_factory&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>); <br>        <span class="hljs-comment">// 将 daily_sink 对象与 logger 关联起来</span><br>        <span class="hljs-keyword">auto</span> log = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;log2&quot;</span>,daily_sink);<br>        <span class="hljs-comment">// 将 关联的 logger 注册到全局</span><br>        spdlog::<span class="hljs-built_in">register_logger</span>(log);<br>        <span class="hljs-comment">// 从全局中获取 指定名称的 logger 进行日志操作</span><br>        spdlog::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;log2&quot;</span>)-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;daily test!&quot;</span>);<br><br>        async_file-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;test,&#123;&#125;&quot;</span>,<span class="hljs-string">&quot;code !!!&quot;</span>);<br>        logger-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>        spdlog::<span class="hljs-built_in">drop_all</span>(); <br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行效果：</span><br><span class="hljs-comment">    创建logs文件夹，在文件夹下生成三个文件，分别是:</span><br><span class="hljs-comment">    async_log.txt 内容为  [2022-08-26 00:00:07.393][Thread 26][info][,]:test,code !!!</span><br><span class="hljs-comment">    dailylog_日期 内容为 [2022-08-26 00:00:07.393] [log2] [info] daily test!</span><br><span class="hljs-comment">    log_日期.log  内容为 [2022-08-26 00:00:07.393][Thread 26][info][,]:test</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><p>多个日志对象使用同一个 sink<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/daily_file_sink.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>* [])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> daily_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_mt&gt;(<span class="hljs-string">&quot;logs/logfile&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>);<br>        <span class="hljs-comment">// create synchronous  loggers</span><br>        <span class="hljs-comment">// 第一个参数为 logger名称 第二个参数为关联的 sink 对象</span><br>        <span class="hljs-keyword">auto</span> net_logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;net&quot;</span>, daily_sink);<br>        <span class="hljs-keyword">auto</span> hw_logger  = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;hw&quot;</span>,  daily_sink);   <br><br>        <span class="hljs-comment">// 不同的logger对象设置不同的日志记录级别</span><br>        net_logger-&gt;<span class="hljs-built_in">set_level</span>(spdlog::level::critical); <span class="hljs-comment">// independent levels</span><br>        hw_logger-&gt;<span class="hljs-built_in">set_level</span>(spdlog::level::debug);<br>         <br>        <span class="hljs-comment">// globally register the loggers so the can be accessed using spdlog::get(logger_name)</span><br>        spdlog::<span class="hljs-built_in">register_logger</span>(net_logger);<br>        spdlog::<span class="hljs-built_in">register_logger</span>(hw_logger);<br>        <span class="hljs-comment">// 通过日志名称获取日志并写入内容</span><br>        spdlog::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;net&quot;</span>)-&gt;<span class="hljs-built_in">critical</span>(<span class="hljs-string">&quot;net logger test&quot;</span>);<br>        spdlog::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;hw&quot;</span>)-&gt;<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;hw logger test&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果：</span><br><span class="hljs-comment">    创建 logs 文件夹，并创建 logfile_日期文件，文件内容如下：</span><br><span class="hljs-comment">    [2022-08-26 00:08:13.301] [net] [critical] net logger test</span><br><span class="hljs-comment">    [2022-08-26 00:08:13.301] [hw] [debug] hw logger test</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><p>一个logger对象关联多个 sink , 每一个sink设置不同的日志级别和格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_color_sinks.h&quot;</span> <span class="hljs-comment">// or &quot;../stdout_sinks.h&quot; if no colors needed</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>* [])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> console_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();<br>        <span class="hljs-comment">// 终端设置打印级别为 warn 日志级别大于 warn 时才会在终端输出</span><br>        console_sink-&gt;<span class="hljs-built_in">set_level</span>(spdlog::level::warn);<br>        console_sink-&gt;<span class="hljs-built_in">set_pattern</span>(<span class="hljs-string">&quot;[multi_sink_example] [%^%l%$] %v&quot;</span>);<br><br>        <span class="hljs-keyword">auto</span> file_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="hljs-string">&quot;logs/multisink.txt&quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 文件设置写入级别为 trace 日志信息级别大于 trace 时才会写入</span><br>        file_sink-&gt;<span class="hljs-built_in">set_level</span>(spdlog::level::trace);<br><br>        spdlog::sinks_init_list sink_list = &#123; file_sink, console_sink &#125;;<br><br>        <span class="hljs-function">spdlog::logger <span class="hljs-title">logger</span><span class="hljs-params">(<span class="hljs-string">&quot;multi_sink&quot;</span>, sink_list.begin(), sink_list.end())</span></span>;<br>        logger.<span class="hljs-built_in">set_level</span>(spdlog::level::debug);<br>        logger.<span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;this should appear in both console and file&quot;</span>);<br>        <span class="hljs-comment">// info 级别低于 warn 不会在终端打印</span><br>        logger.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;this message should not appear in the console, only in the file&quot;</span>);<br><br>        <span class="hljs-comment">// or you can even set multi_sink logger as default logger</span><br>        spdlog::<span class="hljs-built_in">set_default_logger</span>(std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;multi_sink&quot;</span>, spdlog::<span class="hljs-built_in">sinks_init_list</span>(&#123;console_sink, file_sink&#125;)));<br><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> spdlog::spdlog_ex&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行效果：</span><br><span class="hljs-comment">    创建 logs 目录，并创建 multisink.txt 文件，内容为 [2022-08-26 00:12:53.822] [multi_sink] [warning] this should appear in both console and file</span><br><span class="hljs-comment">[2022-08-26 00:12:53.822] [multi_sink] [info] this message should not appear in the console, only in the file</span><br><span class="hljs-comment">    同时将在执行终端中输出以下内容：</span><br><span class="hljs-comment">    [multi_sink_example] [warning] this should appear in both console and file</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>日志记录用户自定义的对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/fmt/ostr.h&quot;</span> <span class="hljs-comment">// must be included</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_sinks.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">some_class</span> &#123;&#125;;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> some_class&amp; c)<br>&#123; <br>    <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;some_class&quot;</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">custom_class_example</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    some_class c;<br>    <span class="hljs-keyword">auto</span> console = spdlog::<span class="hljs-built_in">stdout_logger_mt</span>(<span class="hljs-string">&quot;console&quot;</span>);<br>    console-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;custom class with operator&lt;&lt;: &#123;&#125;..&quot;</span>, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">custom_class_example</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行效果：</span><br><span class="hljs-comment">    终端打印 [2022-08-26 00:27:48.027] [console] [info] custom class with operator&lt;&lt;: some_class..</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br>或通过 fmt 库打印自定义类信息<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/fmt/ostr.h&quot;</span> <span class="hljs-comment">// must be included</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_sinks.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">some_class</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> code;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> OStream&gt;<br>OStream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(OStream &amp;os, <span class="hljs-type">const</span> some_class&amp; to_log)<br>&#123;<br>    fmt::format_to(std::<span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">char</span>&gt;(os), <span class="hljs-string">&quot;&#123;:04X&#125;&quot;</span>, to_log.code);<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">custom_class_example</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    some_class c; c.code = <span class="hljs-number">17</span>;<br>    <span class="hljs-keyword">auto</span> console = spdlog::<span class="hljs-built_in">stdout_logger_mt</span>(<span class="hljs-string">&quot;console&quot;</span>);<br>    console-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;custom class with operator&lt;&lt; using fmt: &#123;&#125;..&quot;</span>, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">custom_class_example</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果</span><br><span class="hljs-comment">    终端打印 [2022-08-26 00:30:08.632] [console] [info] custom class with operator&lt;&lt; using fmt: 0011..</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>spdlog 中使用 _mt 后缀的logger类来表示线程安全的logger对象如 auto logger = spdlog::basic_logger_mt(…);<br>使用 _st 后缀的logger类表示单线程日志对象 如 auto logger = spdlog::basic_logger_st(…);</p><p>对于 sink 也是同样的规则。</p><h2 id="创建logger对象"><a href="#创建logger对象" class="headerlink" title="创建logger对象"></a>创建logger对象</h2><p>单个logger对象包含有一个或者多个 std::shared_ptr<spdlog::sink>,一旦以满足条件的日志级别调佣logger对象，将一次调用保存的 spdlog::sink 对象。<br>在任何地方使用 spdlog::get(“logger_name”) 函数线程安全的返回一个logger共享指针对象。<br>spdlog::get 可能会使你的程序变慢，因为其使用了 mutex ，所以使用 shared_ptr<spdlog::get> 返回并直接使用是很好的方式。</spdlog::get></spdlog::sink></p><p>在创建异步logger对象时，spdlog使用带有专用信息队列的共享的全局线程池。<br>在64位机器上会创建固定数量的预先分配好的槽，大小约为256字节，可以使用 spdlog::init_thread_pool(queue_size,backing_threads_count)来修改默认的设置。</p><p>当想记录一个消息但是队列满了的时候，默认情况下调用将会阻塞直到有槽可用，当logger设置了 async_overflow_policy==overrun_oldest 时，则会将新记录替换最老的记录而且直接阻塞。</p><p>基本的使用方式可以参考快速开始部分的代码。</p><h2 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h2><p>每一个logger的sink有一个定义好的格式，spdlog默认的日志格式为：<br>[2014-10-31 23:46:59.678] [my_loggername] [info] Some message<br>有两种方式可以重新设置logger的输出模式：<br>第一种(推荐) 设置格式化字符串<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">_pattern(<span class="hljs-params">pattern_string</span>)</span>;<br></code></pre></td></tr></table></figure><br>第二种重新实现formatter里面的接口函数<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">_formatter(<span class="hljs-params">std</span>::<span class="hljs-params">make_unique</span>&lt;<span class="hljs-params">my_custom_formatter</span>&gt;()</span>);<br></code></pre></td></tr></table></figure></p><p>能通过以下方式设置logger中已经注册的所有sink的日志输出格式<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">spdlog::set_pattern(<span class="hljs-string">&quot;*** [%H:%M:%S %z] [thread %t] %v ***&quot;</span>);<br></code></pre></td></tr></table></figure><br>或者单独指定某一个logger对象的日志输出格式<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">some_logger-&gt;set_pattern(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);<br></code></pre></td></tr></table></figure><br>或直接指定logger中的sink的输出格式<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">some_logger-&gt;<span class="hljs-built_in">sinks</span>()<span class="hljs-selector-attr">[0]</span>-&gt;<span class="hljs-built_in">set_pattern</span>(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);<br>some_logger-&gt;<span class="hljs-built_in">sinks</span>()<span class="hljs-selector-attr">[1]</span>-&gt;<span class="hljs-built_in">set_pattern</span>(&quot;..&quot;);<br></code></pre></td></tr></table></figure></p><p>格式控制符类似于 strftime 函数中的控制符<br><img src="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/format1.png" alt="1"><br><img src="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/format2.png" alt="2"><br><img src="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/format3.png" alt="3"></p><p>每一个flag标志都可以使用对齐符号对齐，对齐宽度上限为64<br>可以使用 - (左对齐) 和 = (中心对齐) 来控制对齐的边<br>使用 ! 在输出超过限定尺寸的时候进行截断<br><img src="/2022/08/25/spdlog%E4%BD%BF%E7%94%A8/format4.png" alt="4"></p><p>使用自定义的flags 来扩展spdlog<br>可以通过继承 custom_flag_formatter 类，重写 clone() 和 format(…) 抽象函数来实现自定义flags。<br>下面的示例演示了重载 %* 标志的过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/pattern_formatter.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_formatter_flag</span> : <span class="hljs-keyword">public</span> spdlog::custom_flag_formatter<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-type">const</span> spdlog::details::log_msg &amp;, <span class="hljs-type">const</span> std::tm &amp;, spdlog::<span class="hljs-type">memory_buf_t</span> &amp;dest)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string some_txt = <span class="hljs-string">&quot;custom-flag&quot;</span>;<br>        dest.<span class="hljs-built_in">append</span>(some_txt.<span class="hljs-built_in">data</span>(), some_txt.<span class="hljs-built_in">data</span>() + some_txt.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;custom_flag_formatter&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> spdlog::details::<span class="hljs-built_in">make_unique</span>&lt;my_formatter_flag&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">custom_flags_example</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-keyword">auto</span> formatter = std::<span class="hljs-built_in">make_unique</span>&lt;spdlog::pattern_formatter&gt;();<br>    formatter-&gt;<span class="hljs-built_in">add_flag</span>&lt;my_formatter_flag&gt;(<span class="hljs-string">&#x27;*&#x27;</span>).<span class="hljs-built_in">set_pattern</span>(<span class="hljs-string">&quot;[%n] [%*] [%^%l%$] %v&quot;</span>);<br>    spdlog::<span class="hljs-built_in">set_formatter</span>(std::<span class="hljs-built_in">move</span>(formatter));<br>&#125;<br></code></pre></td></tr></table></figure><br>clone()函数必须返回一个经过深拷贝的对象，因为spdlog会传递给每一个正在使用的sink一个新的对象备份。</p><h2 id="sinks"><a href="#sinks" class="headerlink" title="sinks"></a>sinks</h2><p>sink对象是实际上将日志写进到目标里的，每一个sink代表着独特的对象(如文件，终端，数据库)，每一个sink都有它自己的format对象实例。</p><p>每一个logger 包含有一个或多个 std::shared_ptr<sink>，在每一个logger日志以正确的日志级别调用时，logger对象会调用其包含的所有sink的 “sink(log_msg)”函数。</sink></p><p>sink 包含有以 _mt 结尾的多线程版本和 _st结尾的单线程版本，单线程版本无法用于多线程程序中，但由于单线程无锁，所以其速度要快一些。</p><p>下面展示了一部分可用的sinks 完整的sink 可以查看 sinks folder 文件夹</p><p>rotateing_file_sink<br>当日志文件达到最大容量时，关闭并重命名，同时创建新文件。文件最大大小和文件数目均可以在构造时进行指定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// create a thread safe sink which will keep its file size to a maximum of 5MB and a maximum of 3 rotated files.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/rotating_file_sink.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> file_logger = spdlog::<span class="hljs-built_in">rotating_logger_mt</span>(<span class="hljs-string">&quot;file_logger&quot;</span>, <span class="hljs-string">&quot;logs/mylogfile&quot;</span>, <span class="hljs-number">1048576</span> * <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><br>或者先手动创建sink然后传递给logger<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/rotating_file_sink.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> rotating = <span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt; (<span class="hljs-string">&quot;log_filename&quot;</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">auto</span> file_logger = <span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;my_logger&quot;</span>, rotating);<br></code></pre></td></tr></table></figure></p><p>daily_file_sink<br>在指定的时间生成新的日志文件，在日志文件名中添加时间戳。<br>以下示例展示在线程安全的情况下，与每天 14:55分创建日志文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/daily_file_sink.h&quot;</span></span><br>..<br><span class="hljs-keyword">auto</span> daily_logger = spdlog::<span class="hljs-built_in">daily_logger_mt</span>(<span class="hljs-string">&quot;daily_logger&quot;</span>, <span class="hljs-string">&quot;logs/daily&quot;</span>, <span class="hljs-number">14</span>, <span class="hljs-number">55</span>);<br></code></pre></td></tr></table></figure></p><p>simple_file_sink<br>一个简单的没有限制的日志文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/basic_file_sink.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> logger = spdlog::<span class="hljs-built_in">basic_logger_mt</span>(<span class="hljs-string">&quot;mylogger&quot;</span>, <span class="hljs-string">&quot;log.txt&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>stdout_sink/stderr_sink<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_sinks.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> console = spdlog::<span class="hljs-built_in">stdout_logger_mt</span>(<span class="hljs-string">&quot;console&quot;</span>);<br><span class="hljs-keyword">auto</span> err_console = spdlog::<span class="hljs-built_in">stderr_logger_st</span>(<span class="hljs-string">&quot;console&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>带颜色的 stdout_sink/strerr_sink<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/stdout_color_sinks.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> console = spdlog::<span class="hljs-built_in">stdout_color_mt</span>(<span class="hljs-string">&quot;console&quot;</span>);<br><span class="hljs-keyword">auto</span> err_console = spdlog::<span class="hljs-built_in">stderr_color_st</span>(<span class="hljs-string">&quot;console&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>ostream_sink<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/ostream_sink.h &quot;</span></span><br>...<br>std::ostringstream oss;<br><span class="hljs-keyword">auto</span> ostream_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::ostream_sink_mt&gt; (oss);<br><span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;my_logger&quot;</span>, ostream_sink);<br></code></pre></td></tr></table></figure></p><p>syslog_sink<br>POSIX syslog(3) sink 将日志写入到 syslog 中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/syslog_sink.h&quot;</span></span><br>...<br><span class="hljs-function">spdlog::syslog_logger <span class="hljs-title">logger</span><span class="hljs-params">(<span class="hljs-string">&quot;logger_name&quot;</span>, <span class="hljs-string">&quot;my_ident&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure></p><p>systemd_sink<br>将日志内容写到systemd中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/systemd_sink.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> systemd_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::systemd_sink_st&gt;();<br><span class="hljs-function">spdlog::logger <span class="hljs-title">logger</span><span class="hljs-params">(<span class="hljs-string">&quot;logger_name&quot;</span>, systemd_sink)</span></span>;<br></code></pre></td></tr></table></figure></p><p>dist_sink (sink/dist_sink.h)<br>将日志信息记录到一系列的sinks中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/dist_sink.h&quot;</span></span><br>...<br><span class="hljs-keyword">auto</span> dist_sink = <span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::dist_sink_st&gt;();<br><span class="hljs-keyword">auto</span> sink1 = <span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_st&gt;();<br><span class="hljs-keyword">auto</span> sink2 = <span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::simple_file_sink_st&gt;(<span class="hljs-string">&quot;mylog.log&quot;</span>);<br><br>dist_sink-&gt;<span class="hljs-built_in">add_sink</span>(sink1);<br>dist_sink-&gt;<span class="hljs-built_in">add_sink</span>(sink2);<br></code></pre></td></tr></table></figure></p><p>ringbuffer_sink<br>ringbuffer sink 在内存中保存最近的日志记录，可以通过调用 spdlog::sinks::ringbuffer_sink::last_formatted(size_t) 函数取回日志信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/ringbuffer_sink.h&quot;</span></span><br><br><span class="hljs-keyword">auto</span> ringbuffer_sink = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::ringbuffer_sink_mt&gt;(<span class="hljs-number">128</span>);<br><br>std::vector&lt;spdlog::sink_ptr&gt; sinks;<br>sinks.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="hljs-string">&quot;path/to/log.txt&quot;</span>));<br>sinks.<span class="hljs-built_in">push_back</span>(ringbuffer_sink);<br><br><span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="hljs-string">&quot;logger_name&quot;</span>, std::<span class="hljs-built_in">begin</span>(sinks), std::<span class="hljs-built_in">end</span>(sinks));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>    logger-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Log message &#123;&#125;&quot;</span>, i);<br>&#125;<br><br><span class="hljs-comment">// Retrieve all log messages. `log_message` contains 128 messages.</span><br>std::vector&lt;std::string&gt; log_messages = ringbuffer_sink-&gt;<span class="hljs-built_in">last_formatted</span>();<br><span class="hljs-comment">// Retrieve a maximum of 64 log messages.</span><br>std::vector&lt;std::string&gt; log_messages = ringbuffer_sink-&gt;<span class="hljs-built_in">last_formatted</span>(<span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure></p><p>实现自己的sink<br>需要通过实现一个简单的sink接口来实现自定义的sink<br>推荐的方式是继承 base_sink 类，该类中已经包含了锁所以实现线程安全的sink很容易。<br>在这种情况下只需要实现 “sink_it_(..)” 和 “flush_(..)” 函数即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/sinks/base_sink.h&quot;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Mutex&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_sink</span> : <span class="hljs-keyword">public</span> spdlog::sinks::base_sink &lt;Mutex&gt;<br>&#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink_it_</span><span class="hljs-params">(<span class="hljs-type">const</span> spdlog::details::log_msg&amp; msg)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br><br>    <span class="hljs-comment">// log_msg is a struct containing the log entry info like level, timestamp, thread id etc.</span><br>    <span class="hljs-comment">// msg.raw contains pre formatted log</span><br><br>    <span class="hljs-comment">// If needed (very likely but not mandatory), the sink formats the message before sending it to its final destination:</span><br>    spdlog::<span class="hljs-type">memory_buf_t</span> formatted;<br>    spdlog::sinks::base_sink&lt;Mutex&gt;::formatter_-&gt;format(msg, formatted);<br>    std::cout &lt;&lt; fmt::<span class="hljs-built_in">to_string</span>(formatted);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flush_</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span><br><span class="hljs-function">    </span>&#123;<br>       std::cout &lt;&lt; std::flush;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/details/null_mutex.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> my_sink_mt = my_sink&lt;std::mutex&gt;;<br><span class="hljs-keyword">using</span> my_sink_st = my_sink&lt;spdlog::details::null_mutex&gt;;<br></code></pre></td></tr></table></figure></p><h2 id="logger-注册"><a href="#logger-注册" class="headerlink" title="logger 注册"></a>logger 注册</h2><p>spdlog为每一个进程有一个全局的logger，该logger在项目的任何位置都可以轻易获取。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;logger1&quot;</span>)-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>.. <br>.. <br>some other source file..<br>..<br><span class="hljs-keyword">auto</span> l = spdlog::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;logger1&quot;</span>);<br>l-&gt;<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;hello again&quot;</span>);<br></code></pre></td></tr></table></figure><br>如果logger不存在，则会返回一个空指针，需要通过 if(log) 的方式来判断返回值。</p><p>通常情况下不需要手动注册logger，因为其一般会自动完成，可以通过调用 “register_logger(logger_name)” 来实现logger_name名称的logger的注册。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">register_logger</span>(some_logger);<br></code></pre></td></tr></table></figure><br>如果logger_name已经在logger中存在，则会抛出 spdlog::spdlog_ex 异常。</p><p>“drop()” 函数可以将已经注册的logger进行移除，如果logger中已经不包含有共享指针，logger对象将会关闭并且释放它的资源。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">drop</span>(<span class="hljs-string">&quot;logger_name&quot;</span>);<br><span class="hljs-comment">//or remove them all</span><br>spdlog::<span class="hljs-built_in">drop_all</span>()<br></code></pre></td></tr></table></figure></p><h2 id="异步日志"><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2><p>有很多种方式可以创建异步日志，但所有的方式都需要包含头文件”spdlog/async.h”<br>使用<spdlog::async_factory> 模板参数创建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/async.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">async_example</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// default thread pool settings can be modified *before* creating the async logger:</span><br>    <span class="hljs-comment">// spdlog::init_thread_pool(8192, 1); // queue with 8k items and 1 backing thread.</span><br>    <span class="hljs-keyword">auto</span> async_file = spdlog::<span class="hljs-built_in">basic_logger_mt</span>&lt;spdlog::async_factory&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></spdlog::async_factory></p><p>使用 spdlog::create_async<Sink><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> async_file = spdlog::<span class="hljs-built_in">create_async</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>);    <br></code></pre></td></tr></table></figure></Sink></p><p>使用 spdlog::create_async_nb<Sink><br>创建一个在队列满时不会堵塞的logger对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> async_file = spdlog::<span class="hljs-built_in">create_async_nb</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>);<br></code></pre></td></tr></table></figure></Sink></p><p>使用全局线程池直接构建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">init_thread_pool</span>(queue_size, n_threads);<br><span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::async_logger&gt;(<span class="hljs-string">&quot;as&quot;</span>, some_sink, spdlog::<span class="hljs-built_in">thread_pool</span>(), async_overflow_policy::block);<br></code></pre></td></tr></table></figure></p><p>使用自定义线程池直接构建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> tp = std::<span class="hljs-built_in">make_shared</span>&lt;details::thread_pool&gt;(queue_size, n_threads);<br><span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;spdlog::async_logger&gt;(<span class="hljs-string">&quot;as&quot;</span>, some_sink, tp, async_overflow_policy::block);<br></code></pre></td></tr></table></figure></p><p>队列满时的策略：</p><ol><li>阻塞，直到有空闲位置（默认策略）</li><li>丢掉最老的记录同时记录新的日志信息，使用 create_async_nb 或者 spdlog::async_overflow_policy 构建时采用这种策略。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> logger = spdlog::<span class="hljs-built_in">create_async_nb</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="hljs-string">&quot;async_file_logger&quot;</span>, <span class="hljs-string">&quot;logs/async_log.txt&quot;</span>);<br><span class="hljs-comment">// or directly:</span><br> <span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;async_logger&gt;(<span class="hljs-string">&quot;as&quot;</span>, test_sink, spdlog::<span class="hljs-built_in">thread_pool</span>(), spdlog::async_overflow_policy::overrun_oldest);<br></code></pre></td></tr></table></figure></li></ol><p>spdlog的线程池<br>默认情况下，spdlog创建一个大小为8192的线程池，有一个工作线程服务于所有的一步消息。<br>这意味着创建和销毁一个异步logger成本很低，因为它们是直接从共享的线程池中创建的。<br>在64位系统中，所有的队列槽都已预先分配了256字节的大小。<br>可以通过 spdlog::init_thread_pool(queue_size,n_threads) 函数来重新设置线程池的大小，该函数会先销毁原来的线程池，然后重新创建新的线程池，这意味着原来与老线程池关联的logger都会无法工作，所以请确保在构建异步logger之前先调用该函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> tp = std::<span class="hljs-built_in">make_shared</span>&lt;details::thread_pool&gt;(<span class="hljs-number">128</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;async_logger&gt;(<span class="hljs-string">&quot;as&quot;</span>, some_sink, tp, async_overflow_policy::overrun_oldest);<br><br><span class="hljs-keyword">auto</span> tp2 = std::<span class="hljs-built_in">make_shared</span>&lt;details::thread_pool&gt;(<span class="hljs-number">1024</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// create pool with queue of 1024 slots and 4 backing threads</span><br><span class="hljs-keyword">auto</span> logger2 = std::<span class="hljs-built_in">make_shared</span>&lt;async_logger&gt;(<span class="hljs-string">&quot;as2&quot;</span>, some_sink, tp2, async_overflow_policy::block);<br></code></pre></td></tr></table></figure><br>线程池支持添加回调函数作为参数，在每一个线程创建时和销毁前执行回调函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::function&lt;<span class="hljs-type">void</span>()&gt; on_start = []() &#123; <span class="hljs-comment">/* execute on start */</span> &#125;;<br><span class="hljs-keyword">auto</span> on_stop = []() &#123; <span class="hljs-comment">/* execute on stop */</span> &#125;;<br><span class="hljs-keyword">auto</span> tp = std::<span class="hljs-built_in">make_shared</span>&lt;details::thread_pool&gt;(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, on_start, on_stop);<br><br><span class="hljs-comment">// init_thread_pool helper also supports optional on_start and on_stop callbacks</span><br>spdlog::<span class="hljs-built_in">init_thread_pool</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, on_start);<br>spdlog::<span class="hljs-built_in">init_thread_pool</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, on_start, on_stop);<br></code></pre></td></tr></table></figure></p><p>日志顺序<br>默认情况下，spdlog创建一个工作线程这样能保证消息队列的顺序。但在多个线程同时工作的时候，消息可能会重新排序，如果你希望记录的消息还是原来的顺序，那么只能在线程池中创建一个工作线程。</p><h2 id="刷新策略"><a href="#刷新策略" class="headerlink" title="刷新策略"></a>刷新策略</h2><p>默认情况下，spdlog采用与libc相同的刷新策略以保证性能，可以通过以下途径修改：</p><p>手动刷新<br>通过调用logger-&gt;flush() 只是logger刷新其内容，此时logger会调用其包含的sinks中的sink函数。<br>如果对异步logger进行flush()函数操作，flush()会给队列传递刷新消息，此时函数会立即返回。这与一些老版本的spdlog有所不同（老版本的可能会等待flush操作完成）。现在已经无需在退出前显式调用 spdlog::flush() 和 spdlog::shutdown() 。已经能在程序退出前自动调用 flush 和 shutdown 函数了。然而如果你希望在异步logger中使用abort() 或 _exit(-1) 立即退出程序，那还是需要在调用abort 和 _exit(-1) 之前调用logger::shutdown()函数的。</p><p>可以设置刷新的日志级别，设置刷新的最小日志级别，当日志消息等级超过级别后会立刻对日志消息进行刷新<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">my_logger-&gt;<span class="hljs-built_in">flush_on</span>(spdlog::level::err); <br></code></pre></td></tr></table></figure></p><p>间隔一定时间刷新日志<br>基于单工作线程模式周期性的为每一个logger调用 flush() 函数。<br>以下示例演示对于已经注册的logger，每5秒刷新一次日志。<br>该方式只适用于线程安全logger 因为其要周期性的在不同的线程上调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">flush_every</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure></p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>使用ExternalProject_Add 将静态库作为git子模块<br>以下是操作演示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd project_dir\lib<br>git submodule add https://github.com/gabime/spdlog<br>cd spdlog<br>git checkout v1.9.2<br>...<br></code></pre></td></tr></table></figure><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ExternalProject_Add(spdlog<br>    PREFIX spdlog<br>    SOURCE_DIR <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/spdlog<br>    CMAKE_ARGS -DCMAKE_BUILD_TYPE=<span class="hljs-variable">$&#123;CMAKE_BUILD_TYPE&#125;</span><br>    -DCMAKE_CXX_COMPILER=<span class="hljs-variable">$&#123;CMAKE_CXX_COMPILER&#125;</span><br>    -DCMAKE_C_COMPILER=<span class="hljs-variable">$&#123;CMAKE_C_COMPILER&#125;</span><br>    -DCMAKE_TOOLCHAIN_FILE=<span class="hljs-variable">$&#123;CMAKE_TOOLCHAIN_FILE&#125;</span><br>    -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$&#123;STAGING_DIR&#125;</span><br>    -DSPDLOG_BUILD_SHARED=<span class="hljs-keyword">OFF</span><br>)<br></code></pre></td></tr></table></figure><br>然后<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_dependencies</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> spdlog)<br></code></pre></td></tr></table></figure><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">PUBLIC <span class="hljs-variable">$&#123;STAGING_DIR&#125;</span>/<span class="hljs-keyword">include</span>/ <span class="hljs-comment"># spdlog</span><br></code></pre></td></tr></table></figure><br>使用时包含头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spdlog/spdlog.h&quot;</span></span><br></code></pre></td></tr></table></figure></p><p>通过动态库调用spdlog<br>编译spdlog时指定参数 CMAKE_POSITION_INDEPENDENT_CODE 为 True,可以生成动态库<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(cmake_test)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">TRUE</span>)<br><span class="hljs-keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="hljs-keyword">TRUE</span>)<br><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/spdlog&quot;</span>)<br><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)<br><span class="hljs-keyword">add_library</span>(<span class="hljs-keyword">test</span> SHARED <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-keyword">test</span> PRIVATE <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src&quot;</span>)<br><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-keyword">test</span> PRIVATE spdlog::spdlog)<br></code></pre></td></tr></table></figure></p><h2 id="默认-logger"><a href="#默认-logger" class="headerlink" title="默认 logger"></a>默认 logger</h2><p>为了方便，spdlog创建了一个默认的全局logger(线程安全，带颜色的stdout输出)<br>可以直接通过 spdlog::info(..) spdlog::debug(..) 等方式直接调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">spdlog::<span class="hljs-built_in">set_default_logger</span>(some_other_logger);<br>spdlog::<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Use the new default logger&quot;</span>);<br></code></pre></td></tr></table></figure></p><p><a href="https://github.com/gabime/spdlog/wiki/1.-QuickStart">官方文档</a><br><a href="https://www.cnblogs.com/yanke/p/3328402dd2e86456cd35cfcd8ec57198.html">参考链接</a><br><a href="https://www.cnblogs.com/shuqin/p/12214439.html">参考链接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DBNet</title>
    <link href="/2022/08/19/DBNet/"/>
    <url>/2022/08/19/DBNet/</url>
    
    <content type="html"><![CDATA[<h2 id="DBNet"><a href="#DBNet" class="headerlink" title="DBNet"></a>DBNet</h2><p>DBNet适用于文本字符区域定位的算法，是通过对输入图片的文本前景分割，然后进行后处理得到的文本区域定位框的模型，不同于基于检测的文本字符区域定位那种基于检测算法，基于分割的定位算法在后处理上有更大的难度。</p><p><a href="https://arxiv.org/pdf/1911.08947.pdf">论文</a><br><a href="https://github.com/MhLiao/DB">官方代码</a></p><p><img src="/2022/08/19/DBNet/图一.png" alt="图一"><br>图一中蓝色线展示的是一般的字符区域定位流程图。<br>首先通过分割网络模型得到概率图，再通过设定的阈值将概率图转换为二值图<br>然后使用一些启发式的规则，如像素聚合等将文本像素聚合到一起。<br>作者提出的操作流程为红色线展示。目的是将二值化操作加入的分割网络中进行联合优化。这样做的一大好处就是对于每一个图片的阈值都能进行自适应的调整。能很好的区分前景像素与背景像素。<br>然而，标准的二值化函数是不可导的函数，因此作者提出DB(differentiable Binarization) 可导二值化函数，可以在训练分割网络的时候进行求导运算。</p><p>论文的主要贡献如下：</p><ol><li>将二值操作融入到网络的训练过程中，实现CNN网络的端到端训练</li><li>提出DB模块，一个更为鲁棒性的速度更快地文件检测器</li><li>DB模块能在推理的时候移出，因此没有额外的内存和时间开销</li></ol><p>DBNet网络结构如下<br><img src="/2022/08/19/DBNet/%E5%9B%BE%E4%BA%8C.png" alt="图二"><br>基本流程如下图：</p><ol><li>输入图片经过特征金字塔得到不同尺寸的特征图</li><li>将通过特征金字塔得到的特征图上采样到同样的尺寸特征图F</li><li>然后通过特征图F得概率图P和阈值图T</li><li>然后通过概率图P和特征图F得到近似二值图 B<br>在训练的时候使用概率图P,阈值图T,和近似二值化图B 来进行监督。其中概率图P和近似二值化图B使用相同的监督信息。<br>推理的时候可以从近似二值图或者是概率图中得到文本定位框的结果。</li></ol><p><strong>标准二值化</strong><br>给定分割网络得到的概率图 $P \in R^{h*w}$ 其中H和W分别表示特征图的高和宽，通过下面的公式将概率图P转换成二值图。</p><script type="math/tex; mode=display">B_{i,j} = \begin{cases}1 & P_{i,j} < thresh \\0 & otherwise \\\end{cases}</script><p>其中thresh是认为设定的二值化阈值。</p><p><strong>Differentiable binarization 可导二值化</strong><br>可导二值化得到的近似二值化图B可以通过下面的公式，通过概率图P和阈值图T来了求取。</p><script type="math/tex; mode=display">B_{i,j} = \frac{1}{1+e^{-k(P_{i,j}-T_{i,j})}}</script><p>其中的 k 是设定的缩放因子，设定值为50。在效果上可导二值化与标准二值化相似，但是可导二值化能直接在训练分割网络时对其进行优化。可导二值化的自动阈值可以帮助从背景中区分不同的文本区域。同样也可以用于区分那些相隔近的文本区域。如下图示例的样子。<br><img src="/2022/08/19/DBNet/%E5%9B%BE%E4%B8%89.png" alt="图三"></p><p>可导二值化能提升效果可以通过梯度的反向传播来进行解释，下面以二分类交叉熵损失函数为例来说明。<br>定义 $f(x) =\frac{1}{1+e^{-kx}}$ 为可导二值化函数，其中 $x = (P_{i,j}-T_{i,j})$ </p><script type="math/tex; mode=display">l_+ = -log(\frac{1}{1+e^{-kx}})</script><script type="math/tex; mode=display">l_- = -log(1 - \frac{1}{1+e^{-kx}})</script><p>计算 $l_+$ 和 $l_-$ 对x的偏导数</p><script type="math/tex; mode=display">\frac{\partial{l_+}}{\partial{x}} \begin{align}&= (1+e^{-kx})\frac{\partial{(1+e^{-kx})}}{\partial{x}} \\&= (1+e^{-kx})(k\frac{-e^{-kx}}{(1+e^{-kx})^2}) \\&= -kf(x)e^{-kx}\end{align}</script><script type="math/tex; mode=display">\frac{\partial(l_-)}{\partial(x)} \begin{align} &= \frac{\partial(-log(\frac{e^{-kx}}{1+e^{-kx}}))}{\partial(x)} \\&= \frac{\partial(-log(e^{-kx}))}{\partial(x)} + \frac{\partial(log(1+e^{-kx}))}{\partial(x)} \\&= k + \frac{-ke^{-kx}}{1+e^{-kx}} \\&= k(1 - \frac{e^{-kx}}{1+e^{-kx}}) \\&= kf(x)\end{align}</script><p>当k取和k取50时的函数图与导数图如下图：<br><img src="/2022/08/19/DBNet/%E5%9B%BE%E5%9B%9B.png" alt="图四"></p><p>训练标签生成<br><img src="/2022/08/19/DBNet/%E5%9B%BE%E4%BA%94.png" alt="图五"><br>其中红色的为标注的轮廓，蓝色的线表示向内压缩的边界线，绿色线表示向外膨胀的线。<br>probability map概率图的生成受 <a href="https://arxiv.org/pdf/1806.02559.pdf">PSENet</a> 网络的启发。对于给定的一张图片，其中的文本区域可以用一系列的点来表示 $G = \{S_k\}^n_{k=1}$ 其中 n 表示顶点数目，不同的数据集有不同的顶点数。</p><p>使用 vatti clipping algorithm 算法，根据G生成$G_s$，$G_s$表示向内压缩的边界线，偏移量D的计算方式是</p><script type="math/tex; mode=display">D = \frac{A(1-r^2)}{L}</script><p>论文中参数r设置为0.4，L表示标注的边长，A 表示多边形面积。<br>使用同样的方法生成$G_d$，$G_d$表示向外膨胀的线，将$G_s$ $G_d$之间的部分视为文本框的边界，阈值图的标注可以通过计算与真实的 $G$ 之间的距离得到。</p><p>DBNet 的损失函数由三个部分组成，总体表达式如下：</p><script type="math/tex; mode=display">L = L_s + \alpha L_b + \beta L_t</script><p>其中 $L_s$ 是概率图损失， $L_b$ 是近似二值图损失，$L_t$ 表示阈值图损失，论文中设置 $\alpha = 0.1$ $\beta = 10$。<br>对于 $L_b$ 和 $L_s$ 都采用BCE损失函数，其公式如下</p><script type="math/tex; mode=display">L_s = L_b = \sum_{i\in S_t}((y_i)log(x_i)+(1-y_i)log(1-y_i))</script><p>$S_t$ 是一个子集，其中正样本与负样本的比值为 1：3。<br>对于 $L_t$ 选择计算$G_d$与真实标签之间的 L1 距离。</p><script type="math/tex; mode=display">L_t = \sum_{i\in R_d}(\left| y_i - x_i \right|)</script><p>$y_i$ 是概率图中的标签值，$x_i$ 是 $G_d$ 图上对应的值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>dl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake与Makefile</title>
    <link href="/2022/08/12/CMake%E4%B8%8EMakefile/"/>
    <url>/2022/08/12/CMake%E4%B8%8EMakefile/</url>
    
    <content type="html"><![CDATA[<h2 id="单一文件编译"><a href="#单一文件编译" class="headerlink" title="单一文件编译"></a>单一文件编译</h2><h2 id="链接已编译好的动态库"><a href="#链接已编译好的动态库" class="headerlink" title="链接已编译好的动态库"></a>链接已编译好的动态库</h2><h2 id="源码生成库文件"><a href="#源码生成库文件" class="headerlink" title="源码生成库文件"></a>源码生成库文件</h2><h2 id="自动编译第三方依赖"><a href="#自动编译第三方依赖" class="headerlink" title="自动编译第三方依赖"></a>自动编译第三方依赖</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下常用第三方源码安装</title>
    <link href="/2022/08/10/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <url>/2022/08/10/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenBlas"><a href="#OpenBlas" class="headerlink" title="OpenBlas"></a>OpenBlas</h2><ol><li>下载.tra.gz压缩格式的源码</li><li>命令行进入到压缩包所在的目录中</li><li>执行 tar -zxvf OpenBLAS<em>**.tar.gz 其中 </em> 表示版本号信息</li><li>命令行下进入加压缩后得到的目录中</li><li>依次执行以下命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir build<br>cd build<br>cmake -DCMAKE_INSTALL_PREFIX=你要安装目录的绝对路径  ..<br>make -j8<br>make install<br></code></pre></td></tr></table></figure>执行cmake时可以指定其他的参数，具体有那些参数可以通过查看解压后目录下的CMakeLists.txt 文件中的 option 选项，也可以直接修改 CMakeList.txt 文件中option选项的默认值，从而不必要使用cmake进行参数指定。<br>执行make install 时注意权限问题，如果cmake配置时指定的目录当前用户没有操作权限会导致安装失败，需要切换用户或使用sudo make install 进行安装。</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMAKE直接使用 OpenBLAS 编译好的文件</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><br><span class="hljs-keyword">set</span>(includeDir <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">set</span>(libraryDir <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-keyword">set</span>(OpenBLASDir <span class="hljs-string">&quot;/home/xxxx/cppTest/openblas&quot;</span>)  <span class="hljs-comment"># 填安装过程中 cmake 命令执行时指定的安装目录</span><br><span class="hljs-keyword">find_package</span>(OpenBLAS<br>    PATHS <span class="hljs-string">&quot;$&#123;OpenBLASDir&#125;/share/cmake/OpenBLAS/&quot;</span>)<br><span class="hljs-keyword">if</span>(OpenBLAS_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;found OpenBLAS&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OpenBLAS version : $&#123;OpenBLAS_VERSION&#125;&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OpenBLAS include : $&#123;OpenBLAS_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OpenBLAS library : $&#123;OpenBLAS_LIBRARIES&#125;&quot;</span>)<br>    <span class="hljs-keyword">set</span>(includeDir <span class="hljs-variable">$&#123;includeDir&#125;</span> <span class="hljs-variable">$&#123;OpenBLAS_INCLUDE_DIRS&#125;</span>)<br>    <span class="hljs-keyword">set</span>(libraryDir <span class="hljs-variable">$&#123;libraryDir&#125;</span> OpenBLAS::OpenBLAS)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Not Found OpenBLAS&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-keyword">test</span> main.cpp)<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;includeDir $&#123;includeDir&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;libraryDir $&#123;libraryDir&#125;&quot;</span>)<br><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-keyword">test</span> PUBLIC <span class="hljs-variable">$&#123;includeDir&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-keyword">test</span> PUBLIC <span class="hljs-variable">$&#123;libraryDir&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="eigen"><a href="#eigen" class="headerlink" title="eigen"></a>eigen</h2><ol><li>下载所需要版本的 eigen tar.gz格式源码</li><li>使用 tar -zxvf eigen<em>**.tar.gz 其中 </em> 表示版本号</li><li>命令行下进入到解压得到的目录中</li><li>依次执行以下命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir build<br>cd build<br>cmake -DCMAKE_INSTALL_PREFIX=你要安装目录的绝对路径  ..<br>make install<br></code></pre></td></tr></table></figure>eigen 中 cmake 配置选项也可以通过解压缩后目录中的CMakeLists.txt 文件中的option查看，也可以直接修改CMakeLists.txt 文件中option的默认来改变编译选项。<br>eigen 执行完cmake后不需要再进行make -j8 实际上在正常执行完 cmake 命令后，终端会有提示，提示内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">************************************************************<br>-- <br>-- Configured Eigen <span class="hljs-number">3.4</span><span class="hljs-number">.0</span><br>-- <br>-- Available targets (use: make TARGET):<br>-- ---------+--------------------------------------------------------------<br>-- Target   |   Description<br>-- ---------+--------------------------------------------------------------<br>-- install  | Install Eigen. Headers will be installed to:<br>--          |     &lt;CMAKE_INSTALL_PREFIX&gt;/&lt;INCLUDE_INSTALL_DIR&gt;<br>--          |   Using the following values:<br>--          |     CMAKE_INSTALL_PREFIX: /home/shijia/cppTest/eigen3<br>--          |     INCLUDE_INSTALL_DIR:  include/eigen3<br>--          |   Change the install location of Eigen headers using:<br>--          |     cmake . -DCMAKE_INSTALL_PREFIX=yourprefix<br>--          |   Or:<br>--          |     cmake . -DINCLUDE_INSTALL_DIR=yourdir<br>-- doc      | Generate the API documentation, requires Doxygen &amp; LaTeX<br>-- check    | Build <span class="hljs-keyword">and</span> run the unit-tests. Read this page:<br>--          |   http://eigen.tuxfamily.org/index.php?title=Tests<br>-- blas     | Build BLAS library (<span class="hljs-keyword">not</span> the same thing <span class="hljs-keyword">as</span> Eigen)<br>-- uninstall| Remove files installed by the install target<br>-- ---------+--------------------------------------------------------------<br>-- <br>-- Configuring done<br>-- Generating done<br></code></pre></td></tr></table></figure>根据提示内容，直接执行make install 即可，同样的也需要注意cmake 执行时指定的安装路径当前用户有无权限写入，如果没有权限需要切换用户或使用sudo make install 安装。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回归与分类</title>
    <link href="/2022/07/31/%E5%9B%9E%E5%BD%92%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
    <url>/2022/07/31/%E5%9B%9E%E5%BD%92%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p><strong>预测值定量分析，即连续变量预测时，称之为回归</strong></p><p>一元线性回归模型$h_\theta(x) = \theta_0x_0 + b$ 等价于 $y = kx + b$</p><p>多元线性回归模型<br>$h_\theta(x) = \theta_0x_0 + \theta_1x_1+…+\theta_nx_n = \sum^n_{i=0}\theta_ix_i + b = \theta^TX + b$</p><p>当存在有多个值的时候，对于 $y = kx + b$ 可能无法完全拟合所有数据，总会带来一些差异，此时真实值与预测值的关系可以用下述式子表示：</p><p>$y = h_\theta(x) + \epsilon$ 其中 $h_\theta(x)$ 表示预测值， $\epsilon$ 表示误差值。</p><p>假设误差是服从均值为 0 的 $\sigma^2$ 的正态分布。</p><ol><li>为什么均值为0？ 因为均值是预测值</li><li>为什么是正态分布？ 现实中绝大多数事物都服从正态分布，误差满足正态分布能尽可能满足更多的场景，如数据不满足正态分布，则假设失败，模型容易出现非预期的结果</li></ol><p>使用最大似然估计方法，最大化误差出现的概率，这里是最大化概率密度函数</p><p>$argmax L(\theta) = \prod^n_{i=1}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\epsilon^2}{2\sigma^2}} (式一)$ 其中 $\epsilon = y - h_\theta(x)$</p><p><img src="/2022/07/31/%E5%9B%9E%E5%BD%92%E4%B8%8E%E5%88%86%E7%B1%BB/回归图一.png" alt="图一"><br>给定n个样本，每一个样本出现误差的可能性乘在一起，表示了整体出现误差的可能性，所以取连乘。</p><p>当所有的误差都接近均值(即实际值)时,其发生的概率最大，最大似然表示的是预测都尽可能的接近实际值，因为此时概率最大。</p><p>对式一取 ln 对数运算</p><p>$lnL(\theta) = ln(\prod^n_{i=1}\frac{1}{\sqrt{2*\pi}\sigma}e^{-\frac{\epsilon^2}{2\sigma^2}})$<br>$= \sum^n_{i=1}ln(\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\epsilon^2}{2\sigma^2}})$<br>$= \sum^n_{i=1}(ln(\frac{1}{\sqrt{2\pi}\sigma}) + ln(e^(\frac{\epsilon^2}{2\sigma^2})))$<br>$= nln(\frac{1}{\sqrt{2\pi}\sigma} + \sum^n_{i=1}-\frac{\epsilon^2}{2\sigma^2})$<br>$= nln(\frac{1}{\sqrt{2\pi}\sigma}) -\frac{1}{2\sigma^2}\sum^n_{i=1}\epsilon^2$</p><p>上述等式最后一部分中 $nln(\frac{1}{\sqrt{2\pi}\sigma})$ 为常数项, $\sigma$ 为数据集固有属性，为常数，又 $\epsilon = (y_i - h_\theta(x))$ ，因此上述等式最终可以转换为 $J(\theta) = -\frac{1}{2}\sum^n_{i=1}(y_i - h_\theta(x))^2$ 转换为最小化为 $J(\theta) = \frac{1}{2}\sum^n_{i=1}(y_i - h_\theta(x))^2$ 以上称 MSE 或 L2Loss 此时的最小化表示<strong>经验风险最小化</strong> ,让模型尽可能的拟合训练的数据。</p><p>如果在损失函数中增加对训练参数本身数值的约束，则称为对模型的正则化，正则化要求模型的参数越简单越好，称为<strong>结构风险最小化</strong>，即尽可能用简单的模型来拟合训练数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">year,price<br><span class="hljs-number">2000</span>,<span class="hljs-number">3000</span><br><span class="hljs-number">2001</span>,<span class="hljs-number">3500</span><br><span class="hljs-number">2002</span>,<span class="hljs-number">3800</span><br><span class="hljs-number">2003</span>,<span class="hljs-number">5000</span><br><span class="hljs-number">2004</span>,<span class="hljs-number">5200</span><br><span class="hljs-number">2005</span>,<span class="hljs-number">5500</span><br><span class="hljs-number">2006</span>,<span class="hljs-number">5800</span><br><span class="hljs-number">2007</span>,<span class="hljs-number">7000</span><br><span class="hljs-number">2008</span>,<span class="hljs-number">8000</span><br><span class="hljs-number">2009</span>,<span class="hljs-number">9000</span><br><span class="hljs-number">2010</span>,<span class="hljs-number">10000</span><br><span class="hljs-number">2011</span>,<span class="hljs-number">15000</span><br><span class="hljs-number">2012</span>,<span class="hljs-number">23000</span><br><span class="hljs-number">2013</span>,<span class="hljs-number">25000</span><br><span class="hljs-number">2014</span>,<span class="hljs-number">35000</span><br><span class="hljs-number">2015</span>,<span class="hljs-number">40000</span><br><span class="hljs-number">2016</span>,<span class="hljs-number">42000</span><br><span class="hljs-number">2017</span>,<span class="hljs-number">43000</span><br><span class="hljs-number">2018</span>,<span class="hljs-number">40000</span><br><span class="hljs-number">2019</span>,<span class="hljs-number">51000</span><br><span class="hljs-number">2020</span>,<span class="hljs-number">53000</span><br><span class="hljs-number">2021</span>,<span class="hljs-number">52000</span><br><span class="hljs-number">2022</span>,<span class="hljs-number">55000</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> SHprice<br>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Item</span><br>    &#123;<br>        <span class="hljs-type">float</span> year;<br>        <span class="hljs-type">float</span> price;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;Item&gt; <span class="hljs-title">load_data</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; file)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;Item&gt; output;<br>        <span class="hljs-function">fstream <span class="hljs-title">ifile</span><span class="hljs-params">(file,ios::binary|ios::in)</span></span>;<br><br>        string line;<br>        <span class="hljs-built_in">getline</span>(ifile,line);<br><br>        <span class="hljs-comment">// cout&lt;&lt;&quot;first line : &quot;&lt;&lt;line&lt;&lt;endl;</span><br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ifile,line))<br>        &#123;<br>            <span class="hljs-type">int</span> p = line.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>            Item item;<br>            item.year = <span class="hljs-built_in">atof</span>(line.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p).<span class="hljs-built_in">c_str</span>());<br>            item.price = <span class="hljs-built_in">stof</span>(line.<span class="hljs-built_in">substr</span>(p+<span class="hljs-number">1</span>).<span class="hljs-built_in">c_str</span>());<br>            output.<span class="hljs-built_in">emplace_back</span>(item);<br>            <span class="hljs-comment">// cout&lt;&lt;&quot;line : &quot;&lt;&lt;line&lt;&lt;endl;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br><br>    <span class="hljs-function">tuple&lt;Item,Item&gt; <span class="hljs-title">compute_mean_std</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Item&gt;&amp; input)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Item mean&#123;<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>&#125;,stdval&#123;<span class="hljs-number">0.0</span>,<span class="hljs-number">0.</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i:input)<br>        &#123;<br>            mean.year += i.year;<br>            mean.price += i.price;<br>        &#125;<br>        mean.year /= input.<span class="hljs-built_in">size</span>();<br>        mean.price /= input.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i:input)<br>        &#123;<br>            stdval.year += <span class="hljs-built_in">pow</span>(i.year - mean.year,<span class="hljs-number">2.f</span>);<br>            stdval.price += <span class="hljs-built_in">pow</span>(i.price - mean.price,<span class="hljs-number">2.f</span>);<br>        &#125;<br>        stdval.year = <span class="hljs-built_in">sqrt</span>(stdval.year/input.<span class="hljs-built_in">size</span>());<br>        stdval.price = <span class="hljs-built_in">sqrt</span>(stdval.price/input.<span class="hljs-built_in">size</span>());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_tuple</span>(mean,stdval);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">train</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">load_data</span>(<span class="hljs-string">&quot;shanghai.csv&quot;</span>);<br>        Item mean,stdval;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        std::tie： 创建左值引用的 tuple，或将 tuple 解包为独立对象</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-built_in">tie</span>(mean,stdval) = <span class="hljs-built_in">compute_mean_std</span>(data);  <span class="hljs-comment">//将tuple解包成独立对象</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : data)<br>        &#123;<br>            i.year = (i.year - mean.year)/stdval.year;<br>            i.price = (i.price - mean.price)/stdval.price;<br>        &#125;<br><br>        <span class="hljs-type">float</span> k_identity = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> k_sin = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> k_cos = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> lambda = <span class="hljs-number">1e-5</span>;  <span class="hljs-comment">// 正则化权重</span><br>        <span class="hljs-type">float</span> b  = <span class="hljs-number">0.</span>;<br>        <span class="hljs-type">float</span> lr = <span class="hljs-number">0.01</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> iter = <span class="hljs-number">0</span>;iter&lt;<span class="hljs-number">1000</span>;iter++)<br>        &#123;<br><br>            <span class="hljs-type">float</span> predict = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_k_identity = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_k_sin = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_k_cos = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_b = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> loss = <span class="hljs-number">0.</span>; <span class="hljs-comment">// 所有数据的损失值</span><br>            <span class="hljs-type">float</span> L = <span class="hljs-number">0.</span>;  <span class="hljs-comment">// 单个样本的损失值</span><br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : data)<br>            &#123;<br>                predict = k_identity*i.year+k_sin*<span class="hljs-built_in">sin</span>(i.year)+k_cos*<span class="hljs-built_in">cos</span>(i.year)+b;<br>                <span class="hljs-comment">// MSE 和 L2正则化损失</span><br>                L = <span class="hljs-number">0.5</span>*(i.price - predict)*(i.price - predict) + lambda*(k_identity*k_identity+k_sin*k_sin+k_cos*k_cos+b*b);<br><br>                d_k_identity += (predict - i.price)*i.year + <span class="hljs-number">2</span>*lambda*k_identity;<br>                d_k_sin += (predict - i.price)*<span class="hljs-built_in">sin</span>(i.year) + <span class="hljs-number">2</span>*lambda*k_sin;<br>                d_k_cos += (predict - i.price)*<span class="hljs-built_in">cos</span>(i.year) + <span class="hljs-number">2</span>*lambda*k_cos;<br>                d_b += (predict - i.price) + <span class="hljs-number">2</span>*lambda*b;<br><br>                loss += L;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(iter % <span class="hljs-number">100</span> ==<span class="hljs-number">0</span>)<br>                cout&lt;&lt;<span class="hljs-string">&quot;Iter &quot;</span>&lt;&lt;iter&lt;&lt;<span class="hljs-string">&quot;,\tLoss : &quot;</span>&lt;&lt;loss&lt;&lt;endl;<br>            <br>            k_identity = k_identity - d_k_identity*lr;<br>            k_sin = k_sin - d_k_sin*lr;<br>            k_cos = k_cos - d_k_cos*lr;<br>            b = b - d_b*lr;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<br>            <span class="hljs-string">&quot;模型参数：k_identity = %f, k_sin = %f, k_cos = %f, b = %f\n&quot;</span><br>            <span class="hljs-string">&quot;数据集：xm = %f, ym = %f, xs = %f, ys = %f\n&quot;</span>, <br>            k_identity,  k_sin, k_cos, b, mean.year, mean.price, stdval.year, stdval.price<br>        );<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;参数：\nk1, k2, k3, b, xm, ym, xstd, ystd = %f, %f, %f, %f, %f, %f, %f, %f\n&quot;</span>, k_identity,  k_sin, k_cos, b, mean.year, mean.price, stdval.year, stdval.price);<br><br>        <span class="hljs-type">float</span> year          = <span class="hljs-number">2023</span>;<br>        <span class="hljs-type">float</span> x             = (year - mean.year) / stdval.year;<br>        <span class="hljs-type">float</span> predict       = x * k_identity + std::<span class="hljs-built_in">sin</span>(x) * k_sin + std::<span class="hljs-built_in">cos</span>(x) * k_cos + b;<br>        <span class="hljs-type">float</span> predict_price = predict * stdval.price + mean.price;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;预计 %d 年，上海房价将会是：%.3f 元\n&quot;</span>, (<span class="hljs-type">int</span>)year, predict_price);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SHprice::<span class="hljs-built_in">train</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Iter 0, Loss : 8.22601</span><br><span class="hljs-comment">Iter 100,       Loss : 0.332403</span><br><span class="hljs-comment">Iter 200,       Loss : 0.302359</span><br><span class="hljs-comment">Iter 300,       Loss : 0.286353</span><br><span class="hljs-comment">Iter 400,       Loss : 0.275257</span><br><span class="hljs-comment">Iter 500,       Loss : 0.267523</span><br><span class="hljs-comment">Iter 600,       Loss : 0.262132</span><br><span class="hljs-comment">Iter 700,       Loss : 0.258374</span><br><span class="hljs-comment">Iter 800,       Loss : 0.255755</span><br><span class="hljs-comment">Iter 900,       Loss : 0.253929</span><br><span class="hljs-comment">模型参数：k_identity = 0.069261, k_sin = 1.213914, k_cos = -0.574252, b = 0.327150</span><br><span class="hljs-comment">数据集：xm = 2011.000000, ym = 23469.564453, xs = 6.633250, ys = 19034.007812</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">k1, k2, k3, b, xm, ym, xstd, ystd = 0.069261, 1.213914, -0.574252, 0.327150, 2011.000000, 23469.564453, 6.633250, 19034.007812</span><br><span class="hljs-comment">预计 2023 年，上海房价将会是：57114.117 元</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>预测值定性分析，即离散变量预测时，称之为分类</strong></p><p>考虑二分类的问题，在线性回归下，我们希望输出值限制在 (0,1) 之间，表示概率值，同时将输出概率值大于0.5的认为是类别1，小于0.5认为是类别0。</p><script type="math/tex; mode=display">f(x) =  \begin{cases} 1,\,\,h_\theta(x)\geq 0.5\\ 0,\,\,h_\theta(x)<0.5\\ \end{cases}</script><p> 选择 $g(z) = \frac{1}{1+e^z}$ 作为映射函数，将线性回归的结果映射到 0-1 之间，此函数当 $z = 0$时，函数值为 0.5，当 z 趋于无穷大时，函数值<strong>趋于1</strong>,当 z 趋于无穷小时，函数值<strong>趋于0</strong>。</p><p> 令 $z = kx+b$ 则 $h_\theta(x) = \frac{1}{1+e^{-(kx+b)}}$ 此时 $1 - h_\theta(x) = \frac{e^{-(kx+b)}}{1+e^{-(kx+b)}}$ </p><script type="math/tex; mode=display">ln\frac{h_\theta(x)}{1-h_\theta(x)} = kx+b</script><p> 如果将 $h_\theta(x)$ 视为分类为1的可能性，那么 $1 - h_\theta(x)$ 则是分类为0的可能性，两者比值称为对数几率。</p><p> 对于分类问题中，y的取值0,1服从伯努力分布，则有：<br> y为1时的概率，表示为：<br>$P(y = 1|x;\theta) = h_\theta(x)$<br>y为0时的概率，表示为：<br>$P(y = 0|x;\theta) = h_\theta(x)$<br>简化表示为：<br>$P(y|x;\theta) = h_\theta(x)^y(1-h_\theta(x))^{(1-y)}, y = 0,1$</p><p>有似然函数L:<br>$L(\theta) = P(\overrightarrow{y}|x;\theta) = \prod^m_{i=1}P(y^i|x^i;\theta)$<br>带入后有：<br>$L(\theta) = \prod^m_{i=1}h_\theta(x^i)^{y^i}(1 - x^i)^{1-y^i}$<br>此时需要计算参数 $\theta$ 的极大似然估计，找到 $\theta$ 使似然函数 $L(\theta)$ 的值最大化。</p><p>将其取对数得到 (得到的并不是损失函数)：<br>$L(\theta) = \sum^{m}_{i=1}y^ilnh_\theta(x^i)+(1 - y^i)ln(1-h_\theta(x^i))$<br>这里希望得到的是<strong>最大化</strong>的参数估计，不同于回归中的最小化，所以这里参数更新的方式是<strong>梯度上升</strong>。<br>$\theta^+ = \theta + \eta\frac{\partial{L(\theta)}}{\partial{\theta}}$<br>交叉熵求导参考链接。<a href="https://zhuanlan.zhihu.com/p/125753431">参考链接</a></p><p>已知<br>$ln(h_\theta(x)) = ln\frac{1}{1+e^{-{\theta x}}} = -ln(1+e^{-\theta x})$<br>$<br>\begin{aligned}<br>ln(1-h_\theta(x)) &amp;= ln(1 - \frac{1}{1+e^{-\theta x}}) \\<br>        &amp;= ln(\frac{e^{-\theta x}}{1+e^{-\theta x}}) \\<br>        &amp;= ln(e^{-\theta x})-ln(1+e^{-\theta x}) \\<br>        &amp;= -\theta x - ln(1+e^{-\theta x})<br>\end{aligned}<br>$</p><p>$<br>\begin{aligned}<br>L(\theta) &amp;= \sum^{m}_{i=1}(y^ilnh_\theta(x^i)+(1 - y^i)ln(1-h_\theta(x^i))) \\<br>&amp;= \sum^{m}_{i=1}(y^iln((1+e^{-\theta x^i})^{-1}) + (1-y^i)(-\theta x^i - ln(1+e^{-\theta x^i}))) \\<br>&amp;= \sum^m_{i=1}(-y^iln(1+e^{-\theta x^i}) + (1-y^i)(-\theta x^i - ln(1+e^{-\theta x^i}))) \\<br>&amp;= \sum^m_{i=1}(y^i\theta x^i - \theta x^i -ln(1+e^{\theta x^i})) \\<br>&amp;= \sum^m_{i=1}(y^i\theta x^i - ln(e^{\theta x^i}) -ln(1+e^{-\theta x^i})) \\<br>&amp;= \sum^m_{i=1}(y^i\theta x^i - (ln(e^{\theta x^i}) + ln(1+e^{-\theta x^i}))) \\<br>&amp;= \sum^m_{i=1}(y^i\theta x^i - ln(1+e^{\theta x^i}))<br>\end{aligned}<br>$</p><p>$<br>\begin{aligned}<br>\frac{\partial L(\theta)}{\partial \theta} &amp;= \frac{\partial(\sum^m_{i=1}(y^i\theta x^i - ln(1+e^{\theta x^i})))}{\partial \theta}  \\<br>&amp;= \sum^m_{i=1}(y^ix^i - \frac{x^i e^{\theta x^i}}{1+e^{\theta x^i}}) \\<br>&amp;= \sum^m_{i-1}(y^ix^i - \frac{x^i e^{\theta x^i}}{1+\frac{1}{e^{-\theta x^i}}}) \\<br>&amp;= \sum^m_{i=1}(y^ix^i - \frac{x^i e^{\theta x^i}}{\frac{e^{-\theta x^i} + 1}{e^{-\theta x^i}}}) \\<br>&amp; = \sum^m_{i=1}(y^ix^i - x^i(\frac{1}{1+e^{-\theta x^i}})) \\<br>&amp;= \sum^m_{i=1}(x^i(y^i - h_\theta(x^i)))<br>\end{aligned}<br>$</p><p>得到对于每一个参数的更新公式为:<br>$\theta^+_j = \theta_j + \alpha(y^i - h_\theta(x^i))x^i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 测试内容如下，赋值以下内容到 shanghai2.csv</span><br>area,distance,happiness<br><span class="hljs-number">150</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span><br><span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span><br><span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">1</span><br><span class="hljs-number">80</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">1</span><br><span class="hljs-number">100</span>,<span class="hljs-number">3500</span>,<span class="hljs-number">1</span><br><span class="hljs-number">180</span>,<span class="hljs-number">2500</span>,<span class="hljs-number">1</span><br><span class="hljs-number">300</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">200</span>,<span class="hljs-number">4000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">150</span>,<span class="hljs-number">4000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">280</span>,<span class="hljs-number">500</span>,<span class="hljs-number">1</span><br><span class="hljs-number">500</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">80</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">90</span>,<span class="hljs-number">4500</span>,<span class="hljs-number">0</span><br><span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span><br><span class="hljs-number">400</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">0</span><br><span class="hljs-number">450</span>,<span class="hljs-number">100</span>,<span class="hljs-number">0</span><br><span class="hljs-number">320</span>,<span class="hljs-number">3500</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> SHCls<br>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Item</span><br>    &#123;<br>        <span class="hljs-type">float</span> area = <span class="hljs-number">0.</span>;<br>        <span class="hljs-type">float</span> distance = <span class="hljs-number">0.</span>;<br>        <span class="hljs-type">float</span> happiness = <span class="hljs-number">0.</span>;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;Item&gt; <span class="hljs-title">load_data</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; file)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <br>        vector&lt;Item&gt; output;<br><br>        <span class="hljs-function">fstream <span class="hljs-title">fp</span><span class="hljs-params">(file,ios::binary | ios::in)</span></span>;<br>        string line;<br>        <span class="hljs-built_in">getline</span>(fp,line);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(fp,line))<br>        &#123;<br>            <span class="hljs-type">int</span> p0 = line.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-type">int</span> p1 = line.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;,&quot;</span>,p0 + <span class="hljs-number">1</span>);<br><br>            Item item;<br>            <span class="hljs-comment">// 注意索引需要加一</span><br>            item.area = <span class="hljs-built_in">atof</span>(line.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p0).<span class="hljs-built_in">c_str</span>());<br>            item.distance = <span class="hljs-built_in">atof</span>(line.<span class="hljs-built_in">substr</span>(p0+<span class="hljs-number">1</span>,p1).<span class="hljs-built_in">c_str</span>());<br>            item.happiness = <span class="hljs-built_in">atof</span>(line.<span class="hljs-built_in">substr</span>(p1+<span class="hljs-number">1</span>).<span class="hljs-built_in">c_str</span>());<br><br>            output.<span class="hljs-built_in">emplace_back</span>(item);<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br><br>    <span class="hljs-function">tuple&lt;Item,Item&gt; <span class="hljs-title">compute_mean_std</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Item&gt;&amp; input)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Item mean&#123;<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>&#125;,stdval&#123;<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:input)<br>        &#123;<br>            mean.area += i.area;<br>            mean.distance += i.distance;<br>        &#125;<br>        mean.area /= input.<span class="hljs-built_in">size</span>();<br>        mean.distance /= input.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : input)<br>        &#123;<br>            stdval.area += <span class="hljs-built_in">pow</span>(i.area - mean.area,<span class="hljs-number">2.0f</span>);<br>            stdval.distance += <span class="hljs-built_in">pow</span>(i.distance - mean.distance,<span class="hljs-number">2.0f</span>);<br>        &#125;<br>        stdval.area = <span class="hljs-built_in">sqrt</span>((stdval.area)/input.<span class="hljs-built_in">size</span>());<br>        stdval.distance = <span class="hljs-built_in">sqrt</span>(stdval.distance/input.<span class="hljs-built_in">size</span>());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_tuple</span>(mean,stdval);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sigmoid</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-built_in">exp</span>(-x));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; file=<span class="hljs-string">&quot;./shanghai2.csv&quot;</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">load_data</span>(file);<br>        Item mean,stdval;<br><br>        <span class="hljs-built_in">tie</span>(mean,stdval) = <span class="hljs-built_in">compute_mean_std</span>(data);<br>        <span class="hljs-comment">// for循环这里必须取&amp; 否则不能修改向量中的值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i:data)<br>        &#123;<br>            i.area = (i.area - mean.area)/stdval.area;<br>            i.distance = (i.distance - mean.distance)/stdval.distance;<br>        &#125;<br><br>        <span class="hljs-type">float</span> lr = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> k_area = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> k_distance = <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">float</span> b = <span class="hljs-number">0.</span>;<br>        <span class="hljs-type">float</span> loss = <span class="hljs-number">0.0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> iter = <span class="hljs-number">0</span>;iter&lt;<span class="hljs-number">1000</span>;iter++)<br>        &#123;<br>            <span class="hljs-comment">// 每一轮迭代开始都要将梯度和损失值重新设置为 0 </span><br>            <span class="hljs-comment">// 否则会出现收敛问题</span><br>            loss = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_area = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_distance = <span class="hljs-number">0.</span>;<br>            <span class="hljs-type">float</span> d_b = <span class="hljs-number">0.</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; d:data)<br>            &#123;<br>                <span class="hljs-type">double</span> predict = k_area*d.area + k_distance*d.distance + b;<br>                <span class="hljs-type">double</span> y = <span class="hljs-built_in">sigmoid</span>(predict);<br><br>                <span class="hljs-type">float</span> L = -(d.happiness*<span class="hljs-built_in">log</span>(y) + (<span class="hljs-number">1</span>-d.happiness)*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>-y));<br>                <span class="hljs-comment">// 按照上述推导的进行梯度计算，此时与损失函数的值无关</span><br>                d_area     += (y - d.happiness)*d.area;<br>                d_distance += (y - d.happiness)*d.distance;<br>                d_b        += (y - d.happiness);<br>                loss       += L;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(iter % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)<br>                cout &lt;&lt; <span class="hljs-string">&quot;Iter &quot;</span> &lt;&lt; iter &lt;&lt; <span class="hljs-string">&quot;, Loss: &quot;</span> &lt;&lt; loss &lt;&lt; endl;<br><br>            k_area     = k_area - lr*d_area;<br>            k_distance = k_distance - lr*d_distance;<br>            b          = b - lr*d_b;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;模型参数：k_area = %f, k_dist = %f, b = %f\n&quot;</span>, k_area, k_distance, b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数据集：area_mean = %f, dist_mean = %f, area_std = %f, dist_std = %f\n&quot;</span>, <br>            mean.area, mean.distance, stdval.area, stdval.distance<br>        );<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-string">&quot;k_area = %f\n&quot;</span><br>            <span class="hljs-string">&quot;k_distance = %f\n&quot;</span><br>            <span class="hljs-string">&quot;b = %f\n&quot;</span><br>            <span class="hljs-string">&quot;area_mean = %f\n&quot;</span><br>            <span class="hljs-string">&quot;area_std = %f\n&quot;</span><br>            <span class="hljs-string">&quot;distance_mean = %f\n&quot;</span><br>            <span class="hljs-string">&quot;distance_std = %f\n&quot;</span><br>        , k_area, k_distance, b, mean.area, stdval.area, mean.distance, stdval.distance);<br><br>        <span class="hljs-type">float</span> area          = <span class="hljs-number">100</span>;<br>        <span class="hljs-type">float</span> distance      = <span class="hljs-number">2000</span>;<br>        <span class="hljs-type">float</span> norm_area     = (area - mean.area) / stdval.area;<br>        <span class="hljs-type">float</span> norm_dist     = (distance - mean.distance) / stdval.distance;<br>        <span class="hljs-type">float</span> predict       = k_area * norm_area + k_distance * norm_dist + b;<br>        <span class="hljs-type">float</span> logistic      = <span class="hljs-built_in">sigmoid</span>(predict);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在上海，对于房屋面积 %.0f 平方米，距离地铁 %.0f 米的住户而言，他们觉得生活是 【%s】 的.\n&quot;</span>,<br>            area, distance, logistic &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-string">&quot;幸福&quot;</span> : <span class="hljs-string">&quot;并不幸福&quot;</span><br>        );<br>    <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// SHprice::train();</span><br>    SHCls::<span class="hljs-built_in">train</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Iter 0, Loss: 12.6464</span><br><span class="hljs-comment">Iter 100, Loss: 1.27727</span><br><span class="hljs-comment">Iter 200, Loss: 0.824221</span><br><span class="hljs-comment">Iter 300, Loss: 0.619712</span><br><span class="hljs-comment">Iter 400, Loss: 0.499967</span><br><span class="hljs-comment">Iter 500, Loss: 0.420459</span><br><span class="hljs-comment">Iter 600, Loss: 0.363499</span><br><span class="hljs-comment">Iter 700, Loss: 0.320541</span><br><span class="hljs-comment">Iter 800, Loss: 0.286913</span><br><span class="hljs-comment">Iter 900, Loss: 0.259833</span><br><span class="hljs-comment">模型参数：k_area = -10.555772, k_dist = -11.365233, b = 0.702190</span><br><span class="hljs-comment">数据集：area_mean = 225.294113, dist_mean = 2252.941162, area_std = 133.112854, dist_std = 1816.952026</span><br><span class="hljs-comment">k_area = -10.555772</span><br><span class="hljs-comment">k_distance = -11.365233</span><br><span class="hljs-comment">b = 0.702190</span><br><span class="hljs-comment">area_mean = 225.294113</span><br><span class="hljs-comment">area_std = 133.112854</span><br><span class="hljs-comment">distance_mean = 2252.941162</span><br><span class="hljs-comment">distance_std = 1816.952026</span><br><span class="hljs-comment">在上海，对于房屋面积 100 平方米，距离地铁 2000 米的住户而言，他们觉得生活是 【幸福】 的.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++11 计时工具</title>
    <link href="/2022/07/27/c++11%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/07/27/c++11%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>利用c++11标准中的 chrono 库函数实现一个工作类，用于不同单位下耗时的统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerClock</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimerClock</span>() : <span class="hljs-built_in">m_begin</span>(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>()) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; m_begin = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); &#125;<br>    <span class="hljs-comment">//默认输出毫秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//微秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedMicro</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125; <br>    <span class="hljs-comment">//纳秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedNano</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//秒</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedSeconds</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//分</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedMinutes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-comment">//时</span><br>    <span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">elapsedHours</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_begin;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++手动实现求解根号</title>
    <link href="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/"/>
    <url>/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><strong>使用c++语言，在不直接使用相关函数API的情况下，实现根号运算操作</strong></p><h2 id="方式一-梯度下降法"><a href="#方式一-梯度下降法" class="headerlink" title="方式一 梯度下降法"></a>方式一 梯度下降法</h2><ol><li>将求解根号的问题转化为求解函数值解的问题，$\sqrt{x}$ 转化为 $L(t) = (t^2-x)^2$ 当 $L(t) = 0$ 时，$t$ 就是 $\sqrt{x}$ 的结果</li><li>寻找$t$合适的解，使 $L(t) = (t^2-x)^2 = 0$</li><li>找的 $t$ 的解即为需要的结果</li></ol><p><em>此时问题转化为求解 $L(t)$ 的极小值，也就是导数为0的点$</em></p><p><img src="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7%E5%9B%BE%E4%B8%80.png" alt="图一"></p><p>如果橙黄色曲线为 $L(t)$ 函数曲线，当 $t$ 出于与红色位置时，我们需要重新调整 $t$ 的位置，使得 $L(t)$ 的值接近0，此时的问题是将 $t$ 向左调整还是向右调整。</p><p>假设我们在x轴上的调整量为 $\Delta t$($\Delta t$为无穷小量), 此时可以比较将t向左与向右调整 $\Delta t$ 后 ,函数 $L(t\pm \Delta t)$ 的值与 ${L(t)}$ 值的关系。</p><p>如果 $L(t-\Delta t) &lt; L(t)$ 则 $t1 = t - \Delta t$</p><p>如果 $L(t+\Delta t) &lt; L(t)$ 则$t1 = t + \Delta t$</p><p>等价于</p><p>若 $L(t+\Delta t) - L(t) &lt; 0$则<br>$t1 = t + \Delta t$</p><p>若 $L(t-\Delta t) - L(t) &lt; 0$则<br>$t1 = t - \Delta t$</p><p>上两式可以合并为 $t1 = t - \frac{L(t+\Delta t)-L(t)}{\left| L(t+\Delta t) - L(t) \right|}\Delta t$ 其中 $\frac{L(t+\Delta t)-L(t)}{\left| L(t+\Delta t) - L(t) \right|}$ 的作用为取符号。<br>又可做如下的转换 $t1 = t - \frac{\frac{L(t+\Delta t) - L(t)}{\Delta t}}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}\Delta t =t - \frac{L(t+\Delta t) - L(t)}{\Delta t}*\frac{\Delta t}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}$ 其中 $\frac{L(t+\Delta t) - L(t)}{\Delta t}$ 为函数L在t点的导数，$\frac{\Delta t}{\left| \frac{L(t+\Delta t) - L(t)}{\Delta t} \right|}$由于导数为常数，该部分可以视作无穷小。</p><p>此时上式可以化简为 $t1 = t - \alpha*\frac{L(t+\Delta t) - L(t)}{\Delta t} (\alpha \longrightarrow 0^+)$</p><p>这里只有当 $\alpha \longrightarrow 0^+$ 时，该行为才能够成立， $\alpha$也被视为步长。</p><p>当$\alpha$取无穷小时，虽然一定保证下降，但效率太慢，当设置较大值时，可能会暂时越过合适位置，但依然能够通过迭代重新回到合适位置附近，我们将$\alpha$称为学习率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> SQRT<br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @name: 使用导数求解根号</span><br><span class="hljs-comment">   * @msg: </span><br><span class="hljs-comment">   * @param &#123;double&#125; x 输入待求解的数值</span><br><span class="hljs-comment">   * @param &#123;double&#125; alpha 每一步更新的学习率</span><br><span class="hljs-comment">   * @param &#123;double&#125; precision 精度</span><br><span class="hljs-comment">   * @return &#123;*&#125; 返回求解得到的结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt1</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> alpha,<span class="hljs-type">double</span> precision = <span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">double</span> t = x/<span class="hljs-number">2.</span>;<br>    <span class="hljs-type">double</span> L = (t*t - x)*(t*t -x);<br>    <span class="hljs-type">double</span> d = <span class="hljs-number">0.</span>;<br>    <span class="hljs-keyword">while</span> (L &gt; precision)<br>    &#123;<br>      d = <span class="hljs-number">2</span>*(t*t -x)*<span class="hljs-number">2</span>*t;<br>      t = t - alpha*d;<br>      L = (t*t - x)*(t*t -x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  cout&lt;&lt;SQRT::<span class="hljs-built_in">sqrt1</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">1e-8</span>)&lt;&lt;endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>\*<br>输出：<span class="hljs-number">1.41418</span><br>*\<br></code></pre></td></tr></table></figure><p><strong>方式一总结</strong></p><ol><li>梯度下降法是通过局部决定如何调整的算法，如果函数有多个极值，则可能陷入局部极值，因此初始值的选择直接影响收敛结果。</li><li>大的步长一定程度上能跨过局部极值，但也可能由于震荡导致不收敛</li><li>存在有一类算法，可以在一定范围内搜索一个合适步长，使每一次迭代更加稳定</li></ol><h2 id="方式二-牛顿法一"><a href="#方式二-牛顿法一" class="headerlink" title="方式二 牛顿法一"></a>方式二 牛顿法一</h2><p>梯度下降法多用于求解函数极小值的情况，而牛顿法则多用在求解 <strong>函数零点</strong> 时方程的根。</p><p>重新构造函数，将 $\sqrt{x}$ 转化为 $L(t) = t^2 - x$ 当 $L(t) = 0$时，t 就是需要的结果。</p><p><img src="/2022/07/27/cpp%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7/%E6%B1%82%E8%A7%A3%E6%A0%B9%E5%8F%B7%E5%9B%BE%E4%BA%8C.png" alt="图二"></p><p>在 o2 点建立坐标系，此时对于 $f(x)$ 在 $x1$ 处切线可以表示为 $f_o2(x2) = k(x2-x1)+b = f^`(x1)(x2-x1) = -f(x1)$ 最后一个等式可以通过 $o2$ 坐标系看出,在 $o2$ 坐标戏中，切线在 $x = x2$ 时 $y$ 值与 $-f(x1)$ 值相等。</p><p>将上式进行变换得到 </p><p>$x2 -x1 = -\frac{f(x1)}{f^`(x1)}$ </p><p>$x2 = x1 - \frac{f(x1)}{f^`(x1)}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @name: 牛顿法1求解根号</span><br><span class="hljs-comment"> * @msg: </span><br><span class="hljs-comment"> * @param &#123;double&#125; x 要求解的根号数值</span><br><span class="hljs-comment"> * @param &#123;double&#125; precision 精度要求</span><br><span class="hljs-comment"> * @return &#123;*&#125; 返回结果值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt2</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> precision=<span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">double</span> x1 = x/<span class="hljs-number">2.</span>;<br>  <span class="hljs-type">double</span> L = (x1*x1 - x);<br>  <span class="hljs-type">double</span> d = <span class="hljs-number">0.</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">abs</span>(L)&gt;precision)  <span class="hljs-comment">// 注意 abs 函数，可以从零点两侧逼近</span><br>  &#123;<br>    d = <span class="hljs-number">2</span>*x1;<br>    x1 = x1 - L/d;<br>    L = (x1*x1 - x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x1;<br>&#125;<br><span class="hljs-comment">// 输出 ： 1.41421</span><br></code></pre></td></tr></table></figure><h2 id="方式三-牛顿法2"><a href="#方式三-牛顿法2" class="headerlink" title="方式三 牛顿法2"></a>方式三 牛顿法2</h2><p>将原本牛顿法1中对 $L(x)$ 函数的定义转变为 $L(x) = f^<code>(x)$ 即原来 $L(s)$ 表示的是原函数的图像，现在表示的是导函数的图像。根据牛顿法1的结论 $t2 = t1 - \frac&#123;L(t)&#125;&#123;L^</code>(t)}$ 可以得到 $t2 = t1 - \frac{f^`(t)}{f^``(t)}$</p><p>此时将函数L定义为 $L(t) = (t^2 -x)^2 = 0$</p><p>以上要求 $f(x)$ 至少是二阶可导的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt3</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> precision=<span class="hljs-number">1e-8</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">double</span> t = x/<span class="hljs-number">2.</span>;<br>    <span class="hljs-type">double</span> L = (t*t-x)*(t*t-x);<br>    <span class="hljs-type">double</span> d1 =<span class="hljs-number">0.</span>,d2=<span class="hljs-number">0.</span>;<br>    <span class="hljs-keyword">while</span>(L&gt;precision)<br>    &#123;<br>      d1 = <span class="hljs-number">2</span>*(t*t-x)*<span class="hljs-number">2</span>*t;<br>      d2 = <span class="hljs-number">12</span>*t*t - <span class="hljs-number">4</span>*x*t;<br>      t = t - d1/d2;<br>      L = (t*t -x)*(t*t-x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br><span class="hljs-comment">// 输出 ：1.41423 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
